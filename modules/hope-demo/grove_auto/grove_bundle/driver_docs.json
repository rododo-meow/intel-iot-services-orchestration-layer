[{
  "Events": {},
  "ID": 0,
  "GroveName": "Grove - 4-Digit Display",
  "Methods": {
    "write_display_point": {
      "display": "0: not, 1: display",
      "@brief@": "Display the \":\" point or not\n\n"
    },
    "write_display_digits": {
      "chars": "the characters, can be 0~9,A,b,C,d,E,F,V,U.",
      "start_pos": "0~3, 0 is the most left",
      "@brief@": "Display multiple digits.\n\n"
    },
    "write_clear": {
      "@brief@": "Clear all digits and \":\" point.\n"
    },
    "write_display_one_digit": {
      "position": "0~3, 0 is the most left",
      "chr": "the character, can be 0~9,A,b,C,d,E,F,V,U.",
      "@brief@": "Display one digit. \n\n"
    },
    "write_brightness": {
      "@brief@": "Set the brightness.\n\n",
      "brightness": "can be 0,2,7, 7 is the brightest."
    }
  }
}, {
  "Events": {},
  "ID": 1,
  "GroveName": "Grove-3Axis Digital Acc(\u00b11.5g)",
  "Methods": {
    "read_acceleration": {
      "ay": "acceleration in y axis",
      "ax": "acceleration in x axis",
      "az": "acceleration in z axis",
      "@brief@": "read the acceleration in unit g"
    },
    "read_shaked": {
      "shaked": "1: shaked 0: not",
      "@brief@": "read the status if the thing was shacked\nshake can be done in any axis"
    }
  }
}, {
  "Events": {},
  "ID": 2,
  "GroveName": "Grove - Air Quality Sensor",
  "Methods": {
    "read_quality": {
      "quality": "analog reading of this sensor, please use the data as a comparative\tquantity, because it is a qualitative results",
      "@brief@": "Get the analog reading of air quality. The air quality sensor is is designed for comprehensive \nmonitor over indoor air condition. It's responsive to a wide scope of harmful gases, as carbon \nmonixide, alcohol, acetone, thinner, formaldehyde and so on. Due to the measuring mechanism, this \nsensor can not output specific data to describe target gases' concentrations quantitatively. But \nit's still competent enough to be used in applications that require only qualitative results, \nlike auto refresher sprayers and auto air cycling systems. If exposed for a long time to pollution, \nit will be damaged.\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 3,
  "GroveName": "Grove-Barometer(BMP085)",
  "Methods": {
    "read_temperature": {
      "temperature": "unit: Celsius degree",
      "@brief@": "Read a rough temperature value of the envirenment\n\n"
    },
    "read_altitude": {
      "altitude": "the absolute altitude, unit: m",
      "@brief@": ""
    },
    "read_pressure": {
      "pressure": "unit: Pa",
      "@brief@": ""
    }
  }
}, {
  "Events": {
    "button_pressed": "Event which is triggered when the button is pressed, \r\nevent data is the number of PIN where the button is attached.\r"
  },
  "ID": 4,
  "GroveName": "Grove-Button",
  "Methods": {
    "read_pressed": {
      "pressed": "1: pressed, 0: not\r",
      "@brief@": "Get the status of button\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 5,
  "GroveName": "Grove-3Axis Compass",
  "Methods": {
    "read_compass_heading": {
      "heading_deg": "the angle of heading relative to the north, unit: degree",
      "@brief@": ""
    }
  }
}, {
  "Events": {},
  "ID": 6,
  "GroveName": "Grove-Digital Light",
  "Methods": {
    "read_lux": {
      "lux": "the strength of illumination, unit: lux",
      "@brief@": "Reading the lucency of visable light\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 7,
  "GroveName": "Grove-Dry-Reed Relay",
  "Methods": {}
}, {
  "Events": {},
  "ID": 8,
  "GroveName": "Grove-EL Driver",
  "Methods": {
    "write_onoff": {
      "@brief@": "",
      "onoff": "1: on, 0: off\r"
    }
  }
}, {
  "Events": {},
  "ID": 9,
  "GroveName": "Grove-Electromagnet",
  "Methods": {
    "write_onoff": {
      "@brief@": "",
      "onoff": "1: on/generate electromagnetism, 0: off\r"
    }
  }
}, {
  "Events": {
    "encoder_position": "Report the current position when the knob idles for 100ms. The event data is the current position. \n<br> \nPLEASE NOTE: To use the encoder, you need either using battery to power the board or manually soldering to short R1 of Grove-Encoder. \nThis is due to the RX pin of UART interface is pulled up to CP2102's TX pin with a 1K resister and R1 on encoder board \nwith the value 3.3K will obstruct the encoder to correctly pull down the signal A pin. "
  },
  "ID": 10,
  "GroveName": "Grove - Encoder",
  "Methods": {
    "write_enable_acceleration": {
      "enable": "1: enable acceleration, 0: disable",
      "@brief@": "Enable or disable the acceleration feature of the step counting.\n\n"
    },
    "write_reset_position": {
      "position": "",
      "@brief@": "Reset the position to a specified number.\n\n"
    },
    "read_position": {
      "position": "",
      "@brief@": "Read the position of the encoder. The position can be positive or negative number. \nThe position increases when rotate clockwise and decreases when rotate anti-clockwise. <br> \n<br> \nPLEASE NOTE: To use the encoder, you need either using battery to power the board or manually soldering to short R1 of Grove-Encoder. \nThis is due to the RX pin of UART interface is pulled up to CP2102's TX pin with a 1K resister and R1 on encoder board \nwith the value 3.3K will obstruct the encoder to correctly pull down the signal A pin. \n\n"
    }
  }
}, {
  "Events": {
    "fire": "This is the description for event 'fire' \r\nMultipul lines are allowed.\r",
    "event2": "This is the description for event 'event2' \r\nMultipul lines are allowed.\r"
  },
  "ID": 11,
  "GroveName": "Grove_Example",
  "Methods": {
    "read_temp": {
      "temp": "desc for this variable\r",
      "@brief@": "This is the comment for read_temp, with the format showed here \r\nMultipul lines are allowed. \r\n\r\n\r"
    },
    "write_acc_mode": {
      "mode": "desc for param mode\r",
      "@brief@": "This is the description for write_acc_mode.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 12,
  "GroveName": "Generic Analog Input",
  "Methods": {
    "read_analog": {
      "analog": "The measurement of ADC, 0~1023\r",
      "@brief@": "Read the ADC measurement of a generic analog device. The full range is 0~1023.\r\n\r\n\r"
    }
  }
}, {
  "Events": {
    "input_changed": "Event data is the number of the PIN to which the grove is attached\r"
  },
  "ID": 13,
  "GroveName": "Generic Digital Input",
  "Methods": {
    "read_input": {
      "input": "1: on, 0: off\r",
      "@brief@": "Read the input state of a generic digital input device\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 14,
  "GroveName": "Generic Digital Output",
  "Methods": {
    "write_onoff": {
      "@brief@": "Control a generic digital output by writing 1 to pull it high and 0 to pull it low.\r\n\r\n\r",
      "onoff": "1: on/pull high, 0: off/pull low\r"
    },
    "read_onoff_status": {
      "@brief@": "Read back the status of this io\r\n\r\n\r",
      "onoff": "1: on/high, 0: off/low\r"
    }
  }
}, {
  "Events": {},
  "ID": 15,
  "GroveName": "Generic PWM/Analog Output",
  "Methods": {
    "read_pwm": {
      "freq": "unit: Hz\r",
      "duty_percent": "0.0~100.0, float number\r",
      "@brief@": "Read back the parameters of PWM.\r\n\r\n\r"
    },
    "write_pwm_with_freq": {
      "freq": "unit: Hz\r",
      "duty_percent": "0.0~100.0, float number\r",
      "@brief@": "Output a PWM wave on speicfied IO with specified frequency.\r\n\r\n\r"
    },
    "write_pwm": {
      "duty_percent": "0.0~100.0, float number\r",
      "@brief@": "Output a PWM wave on specified IO. The default frequency is 1K Hz.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 16,
  "GroveName": "Grove - Gesture v1.0",
  "Methods": {}
}, {
  "Events": {},
  "ID": 17,
  "GroveName": "Grove-3-Axis Digital Gyro",
  "Methods": {
    "read_temperature": {
      "temp": "unit: Celsius degree",
      "@brief@": ""
    },
    "write_zerocalibrate": {
      "@brief@": "Calibrate the static offsets, need to hold the sensor steadily.\n"
    },
    "read_gyro": {
      "@brief@": "",
      "gz": "unit: deg/s",
      "gy": "unit: deg/s",
      "gx": "unit: deg/s"
    }
  }
}, {
  "Events": {},
  "ID": 18,
  "GroveName": "Grove-I2C Motor Driver",
  "Methods": {
    "write_i2c_address": {
      "addr_7bits": "the new 7bits i2c address\r",
      "@brief@": "Change ths default I2C address, the default address is 0xf\r\n\r\n\r"
    },
    "write_stepper_steps": {
      "steps": "number of steps to move\r",
      "@brief@": "Drive the stepper to move a few steps. To let the stepper rotate forever, steps = 255. \r\nIMPORTANT: Need I2C Motor Driver hardware version >= v1.3 and manually update the firmware according to the \r\nguide inside this zip file: http://www.seeedstudio.com/wiki/images/5/52/On-Chipfirmware_for_Motor_driver.zip  \r\n\r\n\r"
    },
    "write_enable_stepper_mode": {
      "direction": "stepper direction, 0 or 1\r",
      "speed": "defines the time interval the i2C motor driver change its output to drive the stepper, the actul interval time is : motorspeed * 4ms. that is , when motor speed is 10, the interval time would be 40 ms\r",
      "@brief@": "To drive a stepper motor, we need to change the working mode of this driver into stepper mode. \r\nIMPORTANT: Need I2C Motor Driver hardware version >= v1.3 and manually update the firmware according to the \r\nguide inside this zip file: http://www.seeedstudio.com/wiki/images/5/52/On-Chipfirmware_for_Motor_driver.zip \r\n\r\n4ms. that is , when motor speed is 10, the interval time would be 40 ms\r\n\r"
    },
    "write_disable_stepper_mode": {
      "@brief@": "Disable the stepper driving mode, back to default DC motor driving mode\r\n\r"
    },
    "write_dcmotor_speed": {
      "speed_m2": "0~255\r",
      "speed_m1": "0~255\r",
      "@brief@": "Change the speed of DC motor, note that the initial speed is 0 when the module is powered on.\r\n\r\n\r"
    }
  }
}, {
  "Events": {
    "ir_approached": "Triggered when IR object approach the sensor.\r"
  },
  "ID": 19,
  "GroveName": "Grove-IR Distance Interrupter",
  "Methods": {
    "read_approach": {
      "approach": "1: something approached 0: not\r",
      "@brief@": "Read the status if a object is approaching the sensor.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 20,
  "GroveName": "Grove - Infrared Emitter",
  "Methods": {
    "read_protocal_parametersbool": {
      "start_l": "the length of start low signal",
      "@brief@": "Read the parameters of the IR protocol(NEC).\n\n",
      "n_short": "the length of short signal",
      "start_h": "the length of start high signal",
      "n_long": "the length of long signal"
    },
    "write_data_hex": {
      "data_hex": "a string in hex format, e.g. FFBBCC0011",
      "@brief@": "Send a sequence of data with the emitter, using frequency 38KHz.\n\n"
    },
    "write_protocol_parameters": {
      "start_l": "the length of start low signal",
      "@brief@": "Set the protocol parameters. Please don't modify this only if you know what it is.\n\n",
      "n_short": "the length of short signal",
      "start_h": "the length of start high signal",
      "n_long": "the length of long signal"
    },
    "write_data_hex_in_freq": {
      "data_hex": "a string in hex format, e.g. FFBBCC0011",
      "freq_khz": "the frequency of the IR carrier wave, unit KHz.",
      "@brief@": "Send a sequence of data with the emitter, using a specified frequency.\n\n"
    }
  }
}, {
  "Events": {
    "ir_recv_data_hex": "An event which reports the data sequence IR Receiver has received, in HEX string.\r",
    "ir_recv_data_len": "An event which indicates the length of data IR Receiver has received.\r"
  },
  "ID": 21,
  "GroveName": "Grove - Infrared Receiver",
  "Methods": {
    "read_protocol_parameters": {
      "start_l": "the length of start low signal\r",
      "@brief@": "Read the parameters of the IR protocol(NEC).\r\n\r\n\r",
      "n_short": "the length of short signal\r",
      "start_h": "the length of start high signal\r",
      "n_long": "the length of long signal\r"
    },
    "read_last_data_recved": {
      "data": "a string in hex format, e.g. FFBBCC0011\r",
      "len": "the number of bytes\r",
      "@brief@": "Read the last IR data received. The data will be cleared after this read.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 22,
  "GroveName": "Grove - LED Bar",
  "Methods": {
    "write_level": {
      "@brief@": "Display a level\n\n",
      "level": "0~10, the decimal part will control the brightness of the last led, e.g. 9.5 will cause the 10th led light up in half brightness."
    },
    "write_single_led": {
      "@brief@": "Control a single led with brightness\n\n",
      "led": "the index, 1~10",
      "brightness": "0.0~1.0, 1.0 is the brightest, 0.0 let this led off"
    },
    "write_bits": {
      "bits": "each bit controls the led in that bit mask, bit value 0: off, bit value 1: on",
      "@brief@": "Control the leds with the bit mask of a uint16_t integer number\n\n"
    },
    "read_bits": {
      "bits": "each bit indicates the led status in that bit mask, bit value 0: off, bit value 1: on",
      "@brief@": "Read the states of each led, return bit mask of a uint16_t integer number.\n\n"
    },
    "write_toggle": {
      "led": "the index, 1~10",
      "@brief@": "Toggle a single led on or off.\n\n"
    },
    "write_orientation": {
      "green_to_red": "1: green to red 0: red to green",
      "@brief@": "Change the orientation of the level display\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 23,
  "GroveName": "Grove-WS2812 LED Strip 60",
  "Methods": {
    "write_clear": {
      "@brief@": "Set or reset or clear the led strip with a specified color.\n\n",
      "total_led_cnt": "the total count of this strip, max: 60(too many leds will cause the power unstable)",
      "rgb_hex_string": "a rgb value in hex format, e.g. AA55CC (without # or 0x)"
    },
    "write_start_rainbow_flow": {
      "length": "the length of the flow, the flow will always begin with index 0.",
      "@brief@": "Make the strip blink in a rainbow flow\n\n",
      "speed": "1~10, 10 is the fastest.",
      "brightness": "0~100"
    },
    "write_segment": {
      "start": "the start index of the segment(included)",
      "@brief@": "Change the color of some piece of segment of the led strip.\nWe need to specify a list of rgb hex value concatinated into a string.\nThe segment will be defined with a start index and the length.\nThe length equals rgb_hex_string's length / 6. \n\n",
      "rgb_hex_string": "a list of rgb hex value, e.g. FFFFFFBBBBBBCCCCCC000000111111, max length: 240 or 40 rgb hex"
    },
    "write_stop_rainbow_flow": {
      "@brief@": "Stop the rainbow flow.\n"
    }
  }
}, {
  "Events": {
    "mag_approached": "Event data is the number of the PIN to which the grove is attached\r"
  },
  "ID": 24,
  "GroveName": "Grove-Magnetic Switch",
  "Methods": {
    "read_approach": {
      "approach": "1: magnet approached 0: not\r",
      "@brief@": "Read the status if a magnet is approaching the sensor.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 25,
  "GroveName": "Grove-Moisture",
  "Methods": {
    "read_moisture": {
      "moisture": "analog value, range: 0~1023",
      "@brief@": ""
    }
  }
}, {
  "Events": {},
  "ID": 26,
  "GroveName": "Grove-Multichannel Gas Sensor",
  "Methods": {
    "read_CO": {
      "concentration_ppm": "the concentration of CO gas, unit: ppm",
      "@brief@": "Read the concentration of CO gas with unit ppm.\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 27,
  "GroveName": "Grove - OLED Display 1.12''",
  "Methods": {
    "write_clear": {
      "@brief@": "Clear the whole screen\n"
    },
    "write_float": {
      "decimal": "the decimal bits",
      "f": "float number",
      "col": "0~15",
      "@brief@": "Print a float number\n\n",
      "row": "0~7"
    },
    "write_base64_string": {
      "b64_str": "base64 encoded string, the max length is 256",
      "col": "0~15",
      "@brief@": "Print a multiline string encoded in base64. \nSpecial chars is supported. \n\n",
      "row": "0~7"
    },
    "write_scroll_right": {
      "end_row": "lower row index (closed range), 0~7, must be greater or equal start_row.",
      "start_row": "upper row index, 0~7",
      "speed": "0~255",
      "@brief@": "Let the specified rows to scroll right horizontally\n\n"
    },
    "write_scroll_left": {
      "end_row": "lower row index (closed range), 0~7, must be greater or equal start_row.",
      "start_row": "upper row index, 0~7",
      "speed": "0~255",
      "@brief@": "Let the specified rows to scroll left horizontally\n\n"
    },
    "write_string": {
      "@brief@": "Print a string in one line.\nNote that the char must be letter or number, special chars may be ignored. \nTo display multilines and special chars, please use base64_string API.\n\n",
      "col": "0~15",
      "str": "the string to display",
      "row": "0~7"
    },
    "write_integer": {
      "i": "the integer to display",
      "@brief@": "Print a integer\n\n",
      "col": "0~15",
      "row": "0~7"
    },
    "write_brightness": {
      "@brief@": "Set the brightness for the screen\n\n",
      "brightness": "0~255"
    },
    "write_inverse_display": {
      "inverse_or_not": "1: inverse(white background), 0: normal(black background)",
      "@brief@": "Set the screen to display in inverse mode.\n\n"
    },
    "write_stop_scroll": {
      "@brief@": "Stop all scrolling rows.\n"
    }
  }
}, {
  "Events": {
    "ir_moved": "Event data is the number of the PIN to which the grove is attached\r"
  },
  "ID": 28,
  "GroveName": "Grove-PIR Motion Sensor",
  "Methods": {
    "read_approach": {
      "approach": "1: IR object approached, 0: no IR object approached\r",
      "@brief@": "Detect the motion of IR object \r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 29,
  "GroveName": "Grove-Recorder",
  "Methods": {
    "write_play_once": {
      "": "\r",
      "@brief@": "Play the sound which is recorded once.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 30,
  "GroveName": "Grove_Relay",
  "Methods": {
    "write_onoff": {
      "@brief@": "",
      "onoff": "1: on, 0: off\r"
    }
  }
}, {
  "Events": {},
  "ID": 31,
  "GroveName": "Grove-Rotary Angle Sensor",
  "Methods": {}
}, {
  "Events": {},
  "ID": 32,
  "GroveName": "Grove-Servo",
  "Methods": {
    "write_angle": {
      "degree": "the angle in unit degress",
      "@brief@": "Drive the servo to rotate a specified angle and hold on the servo driven PWM signal. <br>\nThe PWM signal maybe polluted by other PWM API calls if the others use different frequency. <br> \ne.g. Grove - Infrared Emitter may affect the action of servo as it's using 38KHz PWM.\n\n"
    },
    "write_angle_motion_in_seconds": {
      "seconds": "the duration of the motion",
      "degree": "the angle in unit degress",
      "@brief@": "Drive the servo to rotate a specified angle and shut down the servo driven PWM signal in specified seconds time. <br> \nFor normal servos, this API still works even if the PWM signal is off. But the servo losts the strength that holding the position. <br> \nThis API will avoid the servo from the influence of other PWM modules, e.g. Grove - Infrared Emitter\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 33,
  "GroveName": "Grove-Solid State Relay",
  "Methods": {}
}, {
  "Events": {},
  "ID": 34,
  "GroveName": "Grove - SPDT Relay(30A)",
  "Methods": {}
}, {
  "Events": {},
  "ID": 35,
  "GroveName": "Grove-Speaker",
  "Methods": {
    "write_sound_ms": {
      "duration_ms": "a duration of x microseconds during which the speaker will produce the sound ",
      "freq": "Hz",
      "@brief@": ""
    },
    "write_sound_start": {
      "freq": "Hz",
      "@brief@": "Start to produce sound with a specified frequency, and wont stop until you send the sound_stop command.\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 36,
  "GroveName": "Grove - Temperature Sensor",
  "Methods": {
    "read_temp": {
      "temperature": "celsius degree with an accuracy of 1.5\u00b0C .\r",
      "@brief@": "Read the celsius temperature from the temperature sensor.\r\n\r\n\r"
    }
  }
}, {
  "Events": {},
  "ID": 37,
  "GroveName": "Grove-Temperature&Humidity",
  "Methods": {
    "read_humidity": {
      "@brief@": "The basic temperature and humidity sensor will update the reading every 2 seconds.\n\n",
      "humidity": "0~100(%)"
    },
    "read_temperature": {
      "celsius_degree": "unit: Celsius degree",
      "@brief@": "The basic temperature and humidity sensor will update the reading every 2 seconds.\n\n"
    },
    "read_temperature_f": {
      "fahrenheit_degree": "Fahrenheit degree",
      "@brief@": "The basic temperature and humidity sensor will update the reading every 2 seconds.\n\n"
    }
  }
}, {
  "Events": {},
  "ID": 38,
  "GroveName": "Grove-Temperature&Humidity Pro",
  "Methods": {
    "read_temperature": {
      "celsius_degree": "unit: Celsius degree",
      "@brief@": ""
    },
    "read_temperature_f": {
      "fahrenheit_degree": "Fahrenheit degree",
      "@brief@": ""
    }
  }
}, {
  "Events": {},
  "ID": 39,
  "GroveName": "Grove - Ultrasonic Ranger",
  "Methods": {
    "read_range_in_inch": {
      "range_cm": "unit: inch\r",
      "@brief@": "Get the range / distance between sensor and object.\r\n\r\n\r"
    },
    "read_range_in_cm": {
      "range_cm": "unit: cm\r",
      "@brief@": "Get the range / distance between sensor and object.\r\n\r\n\r"
    }
  }
}]